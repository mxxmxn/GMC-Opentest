#!/usr/bin/env python
#
# Copyright (C) 2023-2024  Maximilian Martin
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import serial
from PIL import Image


class Secutest:
    def __init__(self, port, address="", baudrate=9600, parity=serial.PARITY_NONE,
                 bytesize=serial.EIGHTBITS, stopbits=serial.STOPBITS_ONE):
        self.port = port
        self.address = address
        self.baudrate = baudrate
        self.parity = parity
        self.bytesize = bytesize
        self.stopbits = stopbits
        self.serial = None

    def connect(self):
        self.serial = serial.Serial(self.port, baudrate=self.baudrate,
                                    parity=self.parity, bytesize=self.bytesize,
                                    stopbits=self.stopbits, xonxoff=True)
        self.serial.timeout = 2  # Time for the device to initialize
        self.serial.write(b'\x06')  # Send ^F to activate checksums

    def disconnect(self):
        if self.serial is not None:
            self.serial.close()

    def send_command(self, operation, operator, parameters="", chain=False):
        message = f"{operation}{self.address}{operator}{parameters}$"
        message += self.calculate_checksum(message) + "\r"  # add checksum and carriage return

        if chain:
            message = message.replace("\r", "|")  # Convert CR to pipe for chaining

        self.serial.write(message.encode('cp850'))

    def calculate_checksum(self, message):
        # Append delimiter before calculating checksum
        checksum = sum(message.encode('cp850')) % 256
        return f"{checksum:02X}"

    def verify_checksum(self, message):
        # Extract checksum from message
        expected_checksum = int(message[-2:], 16)
        # Calculate checksum for message
        calculated_checksum = sum(message[:-2].encode('cp850')) % 256
        if calculated_checksum != expected_checksum:
            raise ValueError("Error:\n\tChecksum verification failed")
        return message[:-3]

    def read_response(self):
        response = self.verify_checksum(self.serial.read_until(b'\r').decode('cp850').strip().strip('>'))
        if response.startswith(".N"):  # Handle not-acknowledge response
            error_code = response.split("x=")[1]
            error_message = self.get_error_message(error_code)
            raise ValueError(f"Error:\n\tSecutest responded with: {error_message}")
        elif response.startswith(".Y"):  # Handle acknowledge response
            return True
        else:
            return response

    def get_error_message(self, error_code):
        error_messages = {
            "x00": "Syntax error",
            "x01": "Checksum error",
            "x02": "IDN error",
            "x03": "Operation error",
            "x04": "Range error",
            "x05": "Remote mode required",
            "x06": "Number error",
            "x07": "Help error",
            "x08": "Connection error",
            "x09": "IT network error",
            "x10": "Internal error",
            "x11": "UHV error",
            "x12": "STO PNR error"
        }
        return error_messages.get(error_code, "Unknown error")

    # TODO: find out function of each relay, documentation missing
    def get_relay_ports(self):  # for development
        self.send_command("REL", "?")
        return self.read_response().split(",")[:-1]

    def beep(self, duration=None):  # values from 1 to 99 work best, default if None
        self.send_command("BEEP", "!", duration)
        return self.read_response()

    def set_label(self, label):  # for procedures  # TODO: test functionality
        self.send_command("LBL", "!", label)
        return self.read_response()

    DOWN_EVENT = 2  # down key pressed
    UP_EVENT = 3  # up key pressed
    ENTER_EVENT = 4  # enter key pressed

    def wait_for_event(self, event):  # use the defined variables  # TODO: test functionality
        self.send_command("EVNT", "!", event)
        return self.read_response()

    def jump(self, bit_number, label):  # for procedures  # TODO: test functionality
        self.send_command("JMP", "!", f"{bit_number} LBL!{label}")
        return self.read_response()

    def run(self, procedure_number):  # for procedures  # TODO: test functionality
        self.send_command("RUN", "!", procedure_number)
        return self.read_response()

    def repeat(self, iterations):  # for procedures  # TODO: test functionality
        self.send_command("RPT", "!", iterations)
        return self.read_response()

    def get_procedures(self):  # for procedures  # TODO: test functionality
        self.send_command("STO", "?")
        return self.read_response()

    def get_procedure(self, procedure_number):  # for procedures  # TODO: test functionality
        self.send_command("STO", "!", f"LIST {procedure_number}")
        return self.read_response()

    # TODO: implement STO command
    # TODO: implement WAIT command
    # TODO: implement BIT command
    # TODO: implement VAR command
    # TODO: implement PRN command

    def get_display(self):  # returns image of display
        secutest.send_command("HCP", "?", "S")  # 'S' for hex, 'Q' for binary (not implemented)
        display_data = []
        for i in range(32):
            hex_line = secutest.read_response()
            for j in range(0, len(hex_line), 2):
                hex_byte = hex_line[j:j + 2]
                binary_byte = bin(int(hex_byte, 16))[2:].zfill(8)
                display_data.extend([int(bit) for bit in binary_byte])
        secutest.read_response()
        display_image = Image.new("1", (128, 128))  # 1-bit pixels, 128x128 display size
        display_image.putdata(display_data)
        return display_image

    # TODO: implement ADD command
    # TODO: implement STR command
    # TODO: implement CFG command
    # TODO: implement DAT command
    # TODO: implement CMP command
    # TODO: implement ISO command
    # TODO: implement BRK command
    # TODO: implement PAT command
    # TODO: implement NTZ command
    # TODO: implement SFC command
    # TODO: implement NCD command
    # TODO: implement CMD command
    # TODO: implement SST command
    # TODO: implement PRX command
    # TODO: implement PRO command
    # TODO: implement MEN command
    # TODO: implement XBY command
    # TODO: implement CBY command
    # TODO: implement PBY command
    # TODO: implement DBY command

    def FONT_1(self): return "01"  # select font 1, small font, all caps, max 32 chars per line
    def FONT_2(self): return "02"  # select font 2, normal font, max 25 chars per line
    def FONT_3(self): return "03"  # select font 3, large font, max 16 chars per line, 2 LF required
    def FONT_4(self): return "04"  # select font 4, huge font, only ASCII, max 8 chars per line, 3 LF required
    def FILL(self, pattern): return "05" + f"{pattern:02x}"  # fill display with vertical lines, following hex-byte is pattern
    def CLR_LINE(self): return "06"  # TODO: test functionality
    def CRLF(self): return "07"  # carriage return and line feed
    def BS(self): return "08"  # backspace of 1 pixel
    def TAB(self): return "09"  # space of 8 pixels
    def LF(self): return "0A"  # line feed
    def ORIGIN(self): return "0B"  # jump to x=0, y=0
    def CLR_DISP(self): return "0C"  # clear display
    def CR(self): return "0D"  # carriage return
    def IMAGE(self, address): return "0E" + f"{address:02x}"  # help image, address from 0 to 30
    def VALUE(self): return "0F"  # print measurement TODO: test functionality
    def LINE_X(self, length): return "10" + f"{length:02x}"  # horizontal line
    def LINE_Y(self, length): return "11" + f"{length:02x}"  # vertical line
    def CLEAR_X(self): return "12"  # TODO: test functionality
    def CLEAR_Y(self): return "13"  # TODO: test functionality
    def ORIGIN_Y(self): return "14"  # jump to y=0 TODO: test functionality
    def REL_Y(self, position): return "15" + f"{position:02x}"  # set relative y position
    def CR2LF(self): return "16"  # TODO: test functionality
    def ABS_Y(self, position): return "17" + f"{position:02x}"  # set absolute y position
    def REL_X(self, position): return "18" + f"{position:02x}"  # set relative x position
    def ABS_X(self, position): return "19" + f"{position:02x}"  # set absolute x position
    def DPN(self): return "1A"  # TODO: test functionality
    def CRY(self): return "1B"  # TODO: test functionality
    def NORMAL(self): return "1D01"  # write black on white
    def INVERTED(self): return "1D02"  # write white on black
    def CLR_EOL(self): return "1D03"  # clear until end of line TODO: test functionality

    def set_display(self, command, string):  # wraps after 16 lines TODO: test functionality
        self.send_command("DIS", "!", command + ";" + string)
        return self.read_response()

    def initialization(self):  # TODO: test functionality
        self.send_command("INI", "!")
        return self.read_response()

    # TODO: implement MES command
    # TODO: implement TAS command
    # TODO: implement WRI command, not used
    # TODO: implement WER command

    def get_memory(self):
        self.send_command("MEM", "?")
        return self.read_response().split("=")[1]

    # TODO: implement KAL command, documentation missing

    def get_version(self):  # TODO: test functionality
        self.send_command("VER", "?")
        return self.read_response()

    def get_identity(self):
        self.send_command("IDN", "?")
        data = self.read_response().split(";")
        return {
            "address": data[0].split("=")[1],  # current address, x = not set
            "manufacturer": data[1],  # initialism of manufacturer, GMN = Gossen Metrawatt Nuremberg
            "type": data[2],  # name of device type
            "model": data[3],  # model number
            "serial": data[4],  # serial number
            "options": data[5],  # installed options
            "user": data[6],  # customizable identification, see "user"
            "hardware": data[7],
            "calibration": data[8],
            "firmware": data[9]
        }

    # TODO implement IDN! command

    def reset(self):  # TODO
        self.send_command("RST", "!")
        return self.read_response()


# Example usage
if __name__ == "__main__":
    secutest = Secutest(port='/dev/ttyUSB0')  # replace with serial port
    secutest.connect()
    try:
        secutest.get_display().save("screenshot.bmp")  # store picture of display
        print("Relay Ports:", secutest.get_relay_ports())  # get relais ports status
        print("Waiting for event:", secutest.wait_for_event(secutest.DOWN_EVENT))  # wait for down button
        print("Beep Response:", secutest.beep())  # beep
        print("Identity:", secutest.get_identity())  # get device information
        print(secutest.set_display(secutest.CLR_DISP() + secutest.ABS_X(10), "Test"))  # write "test" to display
    finally:
        secutest.disconnect()  # disconnect
